<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NJU编译原理</title>
      <link href="/posts/1d2e832b.html"/>
      <url>/posts/1d2e832b.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-0-章"><a href="#第-0-章" class="headerlink" title="第 0 章"></a>第 0 章</h1><p>程序编译过程如下<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.4n82a16tqf.webp"><br>编译原理研究其中的红色虚线框部分，及将源程序转换为汇编程序。<br>利用工具<code>https://godbolt.org/</code> 可以查看不同编译器对同一段代码的编译结果。<br>如下<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.7zqs317i0e.webp"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://docs.compilers.cpl.icu/#/">NJU Compilers</a><br><a href="https://godbolt.org/">Godbolt</a></p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NJU </tag>
            
            <tag> Compilers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61C Sum20</title>
      <link href="/posts/b8f9aa3b.html"/>
      <url>/posts/b8f9aa3b.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><img src="https://www.bilibili.com/video/BV1fC4y147iZ/?share_source=copy_web&vd_source=7c3823b46a52fbbef42b79e01d55c300" alt="B站视频资料"></p>]]></content>
      
      
      <categories>
          
          <category> 体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS61C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cuda编程</title>
      <link href="/posts/a3176164.html"/>
      <url>/posts/a3176164.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cuda编程"><a href="#Cuda编程" class="headerlink" title="Cuda编程"></a>Cuda编程</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><img src="https://space.bilibili.com/218427631?spm_id_from=333.337.search-card.all.click" alt="比飞鸟贵重的多_HKL"></p>]]></content>
      
      
      <categories>
          
          <category> Cuda </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Driver 01 简介</title>
      <link href="/posts/aba14bca.html"/>
      <url>/posts/aba14bca.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Driver-01-简介"><a href="#Linux-Driver-01-简介" class="headerlink" title="Linux-Driver 01 简介"></a>Linux-Driver 01 简介</h1><p>简单介绍一下Linux驱动开发的相关的基础知识。</p><h2 id="什么是Linux"><a href="#什么是Linux" class="headerlink" title="什么是Linux?"></a>什么是Linux?</h2><p>Linux是一个类Unix操作系统的内核，最初由Linus Torvalds在1991年开发。它是开源的，遵循GNU通用公共许可证（GPL），允许用户自由使用、修改和分发。用户可以自行修改内核代码，以满足特定需求。</p><h2 id="Linux构成"><a href="#Linux构成" class="headerlink" title="Linux构成"></a>Linux构成</h2><p>Linux主要分为两个部分：</p><ol><li>用户空间：执行用户程序</li><li>内核空间：内核执行和提供相关服务<br>如图所示：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/linux-driver-01-01.excalidraw.8dx7s418vp.svg"></li></ol><h2 id="Linux内核模块"><a href="#Linux内核模块" class="headerlink" title="Linux内核模块"></a>Linux内核模块</h2><p>内核模块可以被“插入”和“移除”，用于扩展内核功能，实现与内核的隔离。<br>添加内核模块的两种方法：</p><ul><li>直接修改内核源码并重新编译内核</li><li>另一种是在内核运行时动态加载模块，模块就是你想要添加的功能代码，被称为LKM（Loadable Kernel Module）</li></ul><p>可加载内核模块有一下几类：</p><ul><li>设备驱动程序：与硬件进行通信</li><li>文件系统：实现不同的文件系统类型</li><li>系统调用：提供用户空间与内核空间的接口</li></ul><h2 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a>Linux驱动</h2><p>设备驱动程序用于与硬件设备交互。交互的方式通常通过<strong>通信子系统</strong>或者<strong>计算机总线</strong>来实现。<br>分类：</p><ol><li>字符设备<br> 按照逐个字符读取&#x2F;写入数据的硬件文件(Linux中一切皆文件)，例如串口、键盘、鼠标等。数据写入通过同步方式进行，不能被挂载。</li><li>块设备<br> 以块为单位进行数据的传输，例如硬盘、U盘等。数据写入通过异步方式进行，可以被挂载。</li><li>网络设备<br> 通过网络传输数据，例如网卡、无线网卡等。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://embetronicx.com/tutorials/linux/device-drivers/linux-device-driver-part-1-introduction/">Linux Device Driver Tutorial</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux-Driver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AP1400-2-HW2(C++)</title>
      <link href="/posts/70e2ff27.html"/>
      <url>/posts/70e2ff27.html</url>
      
        <content type="html"><![CDATA[<h1 id="AP1400-2-HW2"><a href="#AP1400-2-HW2" class="headerlink" title="AP1400-2-HW2"></a>AP1400-2-HW2</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>目的：模拟加密货币的使用。<br>要求：</p><ol><li>实现两个类：Server和Client</li><li>了解hashing(hash函数)和digital signature(数字签名)的基本概念，在crypto.cpp&#x2F;h中提供</li><li>只能修改server.cpp&#x2F;h和client.cpp&#x2F;h，main.cpp的调试部分</li></ol><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="const用法"><a href="#const用法" class="headerlink" title="const用法"></a>const用法</h2><p>作用：关键字，用于指示变量的值不可更改。<br>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// a的值不可更改</span></span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// 错误，不能修改a的值</span></span><br></pre></td></tr></table></figure><p><code>const</code>修饰的变量必须初始化。<code>const</code>修饰的变量仅仅在当前文件内有效。</p><p>底层处理：在编译时，<code>const</code>修饰的变量在编译的时候被限制为只读，将其存储在只读内存区域。</p><h2 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h2><ol><li>指针常量<br>字面意思，指向常量的指针，指针指向的值不可更改。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">// p是指向常量的指针</span></span><br><span class="line">*p = <span class="number">20</span>; <span class="comment">// 错误，不能修改p指向的值</span></span><br></pre></td></tr></table></figure><ol start="2"><li>常量指针<br>字面意思，指针本身是常量，指针的值不可更改，及指针的指向不可更改。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> p = &amp;a; <span class="comment">// p是常量指针</span></span><br></pre></td></tr></table></figure><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>目的：自动管理动态分配的内存，防止内存泄漏和悬空指针。其底层通过RAII机制实现。<br>优势：</p><ul><li>自动释放内存：智能指针生命周期结束时自动释放内存</li><li>引用计数：共享所有权的智能指针通过引用计数管理资源，资源在最后一个引用被销毁时释放</li><li>避免内存泄漏：通过RAII机制实现</li></ul><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a><code>std::unique_ptr</code></h3><p>特点：独占所有权，不能被复制，只能被移动。<br><code>std::unique_ptr</code>不能被拷贝，必须通过移动语句实现所有权转移，确保了资源的独占性。</p><p><code>std::unique_ptr</code>提供了多种构造函数和赋值操作。</p><ul><li>默认构造函数：创建一个空的<code>std::unique_ptr</code></li><li>指针构造函数：接受一个原始指针，创建一个<code>std::unique_ptr</code>，并接管该指针的所有权</li><li>移动构造函数：接受一个右值引用，转移所有权</li><li>移动赋值操作符：接受一个右值引用，转移所有权</li></ul><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a><code>std::shared_ptr</code></h3><p>特点：共享所有权，可以被多个<code>std::shared_ptr</code>实例共享。通过引用计数管理资源。</p><h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a><code>std::weak_ptr</code></h3><p>特点：不拥有资源，不影响引用计数。用于解决循环引用问题。</p><h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库<random></h2><p>使用步骤</p><ol><li>包含头文件<code>#include &lt;random&gt;</code><br>2，创建随机数生成器对象</li><li>使用分部类生成随机数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数生成器</span></span><br><span class="line">    std::mt19937 generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个均匀分布的随机数生成器，范围从 1 到 10</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印 5 个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; <span class="built_in">distribution</span>(generator) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RISCV指令集</title>
      <link href="/posts/851c2009.html"/>
      <url>/posts/851c2009.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RISCV是一款精简指令集架构，是模块化的，由基本指令集RV32I&#x2F;RV64I和扩展指令集组成。如RV32M(整数乘除法扩展指令集)、RV32A(原子操作扩展指令集)、RV32F(单精度浮点数扩展指令集)、RV32D(双精度浮点数扩展指令集)等。</p><p>指令集主要包含两类，分别是非特权指令集和特权指令集。</p><ul><li>非特权指令集(Unprivileged ISA)：用户态程序使用的指令集。</li><li>特权指令集(Privileged ISA)：内核态程序使用的指令集。</li></ul><p>RISCV处理器：实现RISCV指令集的处理器。<br>开源处理器：BOOM、Rocket Chip、RISCV-Mini</p><h2 id="RV32I-基础指令集"><a href="#RV32I-基础指令集" class="headerlink" title="RV32I 基础指令集"></a>RV32I 基础指令集</h2><h3 id="指令助记符"><a href="#指令助记符" class="headerlink" title="指令助记符"></a>指令助记符</h3><p>指令助记符：单词首字符或字串凭借<br>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set less than &#123;immediate(立即数)&#125; &#123;unsigned(无符号)&#125;</span><br></pre></td></tr></table></figure><p>例如：<br>slt、slti、sltu、sltiu<br>总览<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.2ks94wr9nj.webp"></p><h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>主要由六种指令格式组成</p><ul><li>R型指令：寄存器-寄存器操作指令</li><li>I型指令：寄存器-立即数操作指令</li><li>S型指令：存储指令</li><li>B型指令：分支指令</li><li>U型指令：上位立即数指令</li><li>J型指令：跳转指令<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.58hpf9uqj8.webp"><br>解释：<br>rd：目标寄存器<br>rs1：源寄存器1<br>rs2：源寄存器2<br>imm：立即数<br>opcode：操作码<br>funct3：功能码3<br>funct7：功能码7<br>imm[x]：立即数的第x位</li></ul><p>首先根据opcode确定指令格式，然后根据funct确定具体指令。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>RV32I总共有32个通用寄存器，分别是x0~x31，如图所示<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.175q946y13.webp"></p><ul><li>ra：返回地址寄存器</li><li>sp：栈指针寄存器</li><li>gp：全局指针寄存器</li><li>tp：线程指针寄存器</li><li>t0~t6：临时寄存器</li><li>s0~s11：保存寄存器</li><li>a0~a7：函数参数寄存器</li><li>x0：零寄存器，值恒为0</li></ul><h2 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h2><p>主要介绍以下四类指令</p><ul><li>整数计算</li><li>内存访问</li><li>分支(条件&#x2F;无条件)</li><li>其他指令</li></ul><p>opcode总共有7位，其中opcode[1:0]&#x3D;11，不用考虑，只看opcode[6:2]。功能如下<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.4jog3i473z.webp"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://riscv.org/">RISCV官网</a><br><a href="https://github.com/riscv-boom/riscv-boom">BOOM处理器</a><br><a href="https://bar.eecs.berkeley.edu/projects/boom.html">Berkeley Out-of-Order Machine (BOOM)</a><br><a href="https://github.com/chipsalliance/rocket-chip">rocket-chip</a><br><a href="https://github.com/ucb-bar/riscv-mini">riscv-mini</a><br><a href="RISC-V-Reader-Chinese-v2p1">RISCV手册</a><br>[Linux GNU C程序观察]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Short Cut</title>
      <link href="/posts/4e50a0eb.html"/>
      <url>/posts/4e50a0eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="Short-Cut使用"><a href="#Short-Cut使用" class="headerlink" title="Short Cut使用"></a>Short Cut使用</h1><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>新建工程后导入素材，如下<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.175pmjiky2.webp"><br>将图片拖入下方的视频轨道<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.77dvr9xlbk.webp"><br>拖动时间轴上的图片重合，实现专场效果<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.7i0pkfjle6.webp"><br>添加音频轨道<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.232720awq7.webp"><br>接下来添加字幕<br>选中轨道，添加滤镜<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.7axhp7wpj9.webp"><br>添加文本<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.7lkbiddbzb.webp"><br>点击关键帧，设置字体显示的时间<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.60ukiwrgmr.webp"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>空格: 播放&#x2F;暂停</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Kernel 0 资料整理</title>
      <link href="/posts/8fbff589.html"/>
      <url>/posts/8fbff589.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/0xAX/linux-insides?tab=readme-ov-file">linux-insides</a><br><a href="https://github.com/linux-kernel-labs-zh/docs-linux-kernel-labs-zh-cn">docs-linux-kernel-labs-zh-cn</a><br><a href="http://www.wowotech.net/">蜗窝科技</a><br><a href="https://elixir.bootlin.com/linux/v6.14.3/source">Linux Kernel Source</a><br><a href="https://lwn.net/">lwn</a><br>Linux Kernel Programming: A comprehensive and practical guide to kernel internals, writing modules, and kernel synchronization 2nd Edition,</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode集合</title>
      <link href="/posts/4efd5505.html"/>
      <url>/posts/4efd5505.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode集合"><a href="#LeetCode集合" class="headerlink" title="LeetCode集合"></a>LeetCode集合</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul><li><input checked="" disabled="" type="checkbox"> 21</li><li><input checked="" disabled="" type="checkbox"> 86</li><li><input disabled="" type="checkbox"> 23</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题</title>
      <link href="/posts/10097df6.html"/>
      <url>/posts/10097df6.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><ul><li><input checked="" disabled="" type="checkbox"> 2025.08.14 1780</li><li><input checked="" disabled="" type="checkbox"> 2025.08.15 324</li><li><input checked="" disabled="" type="checkbox"> 2025.08.18 679</li><li><input checked="" disabled="" type="checkbox"> 2025.08.30 36</li><li><input checked="" disabled="" type="checkbox"> 2025.08.31 37</li><li><input checked="" disabled="" type="checkbox"> 2025.09.02 3025</li><li><input checked="" disabled="" type="checkbox"> 2025.09.03 3027</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PKE lab1笔记</title>
      <link href="/posts/4e1127f1.html"/>
      <url>/posts/4e1127f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="PKE-lab1笔记"><a href="#PKE-lab1笔记" class="headerlink" title="PKE lab1笔记"></a>PKE lab1笔记</h1><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p>一个应用的编译和链接过程大致如下：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/pkelab1_1.excalidraw.7pm0ii5gf.svg"></p><ol><li>预处理<ul><li>处理<code>#include</code>、<code>#define</code>等预处理指令，生成.i文件</li></ul></li><li>编译<ul><li>将.i文件编译成汇编代码，生成.s文件</li></ul></li><li>汇编<ul><li>将.s文件汇编成目标文件，生成.o文件</li></ul></li><li>链接<ul><li>将多个.o文件和库文件链接成可执行文件，生成可执行文件</li></ul></li></ol><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>( <span class="string">&quot;Hello world!\n&quot;</span> );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- 编译：</span><br><span class="line">```shell</span><br><span class="line">riscv64-unknown-elf-gcc -c ./hello.c</span><br></pre></td></tr></table></figure><p>-c：表示只编译，不链接，生成目标文件hello.o。<br>编译完成后得到hello.o文件，查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file ./hello.o</span><br><span class="line">./hello.o: ELF 64-bit LSB relocatable, UCB RISC-V, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><ul><li>链接：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc -o ./hello ./hello.o</span><br></pre></td></tr></table></figure><p>上述命令会自动hello可执行文件，查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file ./hellold</span><br><span class="line">hellold: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped</span><br></pre></td></tr></table></figure><p>与上面不同的是，生成的文件类型是executable，可执行文件。statically linked表示是静态链接的。</p><p>查看ELF文件的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-readelf -h ./hello</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           RISC-V</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x100c0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          19560 (bytes into file)</span><br><span class="line">  Flags:                             0x5, RVC, double-float ABI</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         2</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         15</span><br><span class="line">  Section header string table index: 14</span><br></pre></td></tr></table></figure><p>从结果看出，总共有2个程序段(segment)，15个节(section)，入口地址0x100c0。</p><p>查看具体的节信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-readelf -S ./hello</span><br><span class="line">There are 15 section headers, starting at offset 0x4c68:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         00000000000100b0  000000b0</span><br><span class="line">       0000000000002552  0000000000000000  AX       0     0     2</span><br><span class="line">  [ 2] .rodata           PROGBITS         0000000000012608  00002608</span><br><span class="line">       0000000000000012  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .eh_frame         PROGBITS         000000000001361c  0000261c</span><br><span class="line">       0000000000000004  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .init_array       INIT_ARRAY       0000000000013620  00002620</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [ 5] .fini_array       FINI_ARRAY       0000000000013630  00002630</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [ 6] .data             PROGBITS         0000000000013638  00002638</span><br><span class="line">       0000000000000f58  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 7] .sdata            PROGBITS         0000000000014590  00003590</span><br><span class="line">       0000000000000040  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 8] .sbss             NOBITS           00000000000145d0  000035d0</span><br><span class="line">       0000000000000028  0000000000000000  WA       0     0     8</span><br><span class="line">  [ 9] .bss              NOBITS           00000000000145f8  000035d0</span><br><span class="line">       0000000000000060  0000000000000000  WA       0     0     8</span><br><span class="line">  [10] .comment          PROGBITS         0000000000000000  000035d0</span><br><span class="line">       0000000000000012  0000000000000001  MS       0     0     1</span><br><span class="line">  [11] .riscv.attributes RISCV_ATTRIBUTE  0000000000000000  000035e2</span><br><span class="line">       0000000000000035  0000000000000000           0     0     1</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00003618</span><br><span class="line">       0000000000000f48  0000000000000018          13    78     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  00004560</span><br><span class="line">       0000000000000687  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  00004be7</span><br><span class="line">       000000000000007e  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), p (processor specific)</span><br></pre></td></tr></table></figure><p>可以看到有如下：</p><ul><li><code>.text</code>：可执行节</li><li><code>.rodata</code>：只读数据节</li><li><code>.data</code>：已初始化数据节</li><li><code>.bss</code>：未初始化数据节</li><li><code>.symtab</code>：符号表<br>…</li></ul><p>查看程序段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-readelf -l ./hello</span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x100c0</span><br><span class="line">There are 2 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000010000 0x0000000000010000</span><br><span class="line">                 0x000000000000261a 0x000000000000261a  R E    0x1000</span><br><span class="line">  LOAD           0x000000000000261c 0x000000000001361c 0x000000000001361c</span><br><span class="line">                 0x0000000000000fb4 0x000000000000103c  RW     0x1000</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata </span><br><span class="line">   01     .eh_frame .init_array .fini_array .data .sdata .sbss .bss </span><br></pre></td></tr></table></figure><p>两个段：</p><ul><li>00：只读段，包含<code>.text</code>和<code>.rodata</code>节，可执行代码段</li><li>01：读写段，包含<code>.eh_frame</code>、<code>.init_array</code>、<code>.fini_array</code>、<code>.data</code>、<code>.sdata</code>、<code>.sbss</code>和<code>.bss</code>节，为数据段</li></ul><p>使用反汇编objdump查看汇编代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-objdump -D ./hello | less</span><br><span class="line">./hello:     file format elf64-littleriscv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line">...</span><br><span class="line">000000000001014a &lt;main&gt;:</span><br><span class="line">   1014a:       1141                    addi    sp,sp,-16</span><br><span class="line">   1014c:       e406                    sd      ra,8(sp)</span><br><span class="line">   1014e:       e022                    sd      s0,0(sp)</span><br><span class="line">   10150:       0800                    addi    s0,sp,16</span><br><span class="line">   10152:       67c9                    lui     a5,0x12</span><br><span class="line">   10154:       60878513                addi    a0,a5,1544 # 12608 &lt;__errno+0xc&gt;</span><br><span class="line">   10158:       1c0000ef                jal     ra,10318 &lt;puts&gt;</span><br><span class="line">   1015c:       4781                    li      a5,0</span><br><span class="line">   1015e:       853e                    mv      a0,a5</span><br><span class="line">   10160:       60a2                    ld      ra,8(sp)</span><br><span class="line">   10162:       6402                    ld      s0,0(sp)</span><br><span class="line">   10164:       0141                    addi    sp,sp,16</span><br><span class="line">   10166:       8082                    ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在调用printf时，转换成了puts函数调用，因为是静态链接，所以在编译时，所有的库函数都被链接进来了。</p><h2 id="Makefile文件分析"><a href="#Makefile文件分析" class="headerlink" title="Makefile文件分析"></a>Makefile文件分析</h2><p>以lab1_1为例，分析其Makefile文件内容：</p><p>todo ….</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spike ./obj/riscv-pke ./obj/app_helloworld</span><br><span class="line">In m_start, hartid:0</span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: 2048 MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: ./obj/app_helloworld</span><br><span class="line">Application program entry point (virtual address): 0x0000000081000000</span><br><span class="line">Switch to user mode...</span><br><span class="line">call do_syscall to accomplish the syscall and lab1_1 here.</span><br><span class="line"></span><br><span class="line">System is shutting down with exit code -1.</span><br></pre></td></tr></table></figure><p>启动命令主要分了三部分：</p><ul><li>spike：模拟器的命令</li><li>.&#x2F;obj&#x2F;riscv-pke：内核</li><li>.&#x2F;obj&#x2F;app_helloworld：被测试的应用程序<br>将内核编译为ELF文件，使用spike模拟器加载。<br>查看riscv-pke的ELF文件信息：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-readelf -h ./obj/riscv-pke</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           RISC-V</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x80000536</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          92504 (bytes into file)</span><br><span class="line">  Flags:                             0x5, RVC, double-float ABI</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         2</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         19</span><br><span class="line">  Section header string table index: 18</span><br></pre></td></tr></table></figure><p>程序段信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-readelf -l ./obj/riscv-pke</span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x80000536</span><br><span class="line">There are 2 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000080000000 0x0000000080000000</span><br><span class="line">                 0x0000000000003587 0x0000000000003587  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000005000 0x0000000080004000 0x0000000080004000</span><br><span class="line">                 0x0000000000001412 0x00000000000028c0  RW     0x1000</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .text .rodata </span><br><span class="line">   01     .htif .data .bss </span><br></pre></td></tr></table></figure><p>可以看到程序入口地址是0x80000536，程序段包含两个段：</p><ul><li>00：地址0x80000000</li><li>01：地址0x80004000<br>在spike模拟器中，模拟2GB的内存，物理内存范围[0x80000000, 0xffffffff]。程序的地址是虚拟地址，此时代理内核的虚拟地址的起始地址&#x3D;物理地址的起始地址，此时无需做虚拟地址到物理地址的转换。<br>程序入口地址0x80000536，掺看kernel.lds文件：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRY( _mentry )</span><br><span class="line">riscv64-unknown-elf-objdump -D ./obj/riscv-pke | grep _mentry</span><br><span class="line">0000000080000536 &lt;_mentry&gt;</span><br></pre></td></tr></table></figure><p>入口地址为mentry函数。</p><h3 id="mentry机器模式入口函数"><a href="#mentry机器模式入口函数" class="headerlink" title="mentry机器模式入口函数"></a>mentry机器模式入口函数</h3><p>mentry函数的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># _mentry 是内核的入口函数</span><br><span class="line"># 进入_mentry之前, 通过spike设置两个寄存器a0(x10)，a1(x11)</span><br><span class="line"># [a0] = 处理器ID(RISCV里面称为HART)</span><br><span class="line"># [a1] = 指向DTS（设备树字符串）的指针，该字符串存储在spike模拟的RISC-V客户机内存中。</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">.globl _mentry</span><br><span class="line">_mentry:</span><br><span class="line">    # [mscratch] = 0; 指向机器模式计算机的栈底</span><br><span class="line">    csrw mscratch, x0</span><br><span class="line"></span><br><span class="line">    # 为每个HART分配一个4096字节的栈</span><br><span class="line">    la sp, stack0# stack0 在 kernel/machine/minit.c 中静态定义</span><br><span class="line">    li a3, 4096# 4096字节的栈</span><br><span class="line">    csrr a4, mhartid# [mhartid] = 核心ID</span><br><span class="line">    addi a4, a4, 1</span><br><span class="line">    mul a3, a3, a4</span><br><span class="line">    add sp, sp, a3# 重新排列栈指针，避免重叠</span><br><span class="line"></span><br><span class="line">    # 调用 m_start</span><br><span class="line">    call m_start</span><br></pre></td></tr></table></figure><p>这段代码主要是为内核分配4KB的栈空间，并调用m_start函数。<br>m_start函数为机器模式的启动代码<br>查看m_start函数，定义在kernel&#x2F;machine&#x2F;minit.c中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// m_start: 机器模式 C 入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">m_start</span><span class="params">(<span class="type">uintptr_t</span> hartid, <span class="type">uintptr_t</span> dtb)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化 spike 文件接口（stdin, stdout, stderr）</span></span><br><span class="line">  <span class="comment">// 所有以 &quot;spike_&quot; 为前缀的函数都定义在 spike_interface/ 目录下的代码中，</span></span><br><span class="line">  <span class="comment">// sprint 也定义在 spike_interface/spike_utils.c 中</span></span><br><span class="line">  spike_file_init();</span><br><span class="line">  sprint(<span class="string">&quot;In m_start, hartid:%d\n&quot;</span>, hartid);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用设备树二进制（DTB）初始化 HTIF（主机-目标接口）和内存</span></span><br><span class="line">  <span class="comment">// init_dtb() 在上面定义</span></span><br><span class="line">  init_dtb(dtb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将前一个特权级别设置为 S（监督者）模式，&#x27;mret&#x27; 指令执行后将进入 S 模式</span></span><br><span class="line">  <span class="comment">// write_csr 是在 kernel/riscv.h 中定义的宏</span></span><br><span class="line">  write_csr(mstatus, ((read_csr(mstatus) &amp; ~MSTATUS_MPP_MASK) | MSTATUS_MPP_S));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将机器异常程序计数器（mepc）设置为 s_start，为 mret 做准备（需要 gcc -mcmodel=medany）</span></span><br><span class="line">  write_csr(mepc, (uint64)s_start);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将所有中断和异常委托给监督者模式（S 模式）。</span></span><br><span class="line">  <span class="comment">// delegate_traps() 在上面定义。</span></span><br><span class="line">  delegate_traps();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换到监督者模式（S 模式）并跳转到 s_start()，即将程序计数器（pc）设置为 mepc</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>初始化spike接口</li><li>初始化设备树二进制（DTB）</li><li>设置特权级别为S模式</li><li>执行mret，返回s模式，跳转到s_start函数</li></ul><h3 id="s-start监督者模式入口函数"><a href="#s-start监督者模式入口函数" class="headerlink" title="s_start监督者模式入口函数"></a>s_start监督者模式入口函数</h3><p>s_start函数为S模式的启动代码，定义在kernel&#x2F;kernel.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// s_start: riscv-pke OS 内核的 S 模式入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">s_start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  sprint(<span class="string">&quot;Enter supervisor mode...\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 注意：在 lab1 中我们使用直接映射（即 Bare 模式）进行内存映射。</span></span><br><span class="line">  <span class="comment">// 这意味着：虚拟地址 = 物理地址</span></span><br><span class="line">  <span class="comment">// 因此，目前我们需要将 satp 设置为 0。我们会在 lab2_x 中启用分页。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// write_csr 是在 kernel/riscv.h 中定义的宏</span></span><br><span class="line">  write_csr(satp, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应用程序代码（ELF 文件）首先被加载到内存中，然后开始执行</span></span><br><span class="line">  load_user_program(&amp;user_app);</span><br><span class="line"></span><br><span class="line">  sprint(<span class="string">&quot;Switch to user mode...\n&quot;</span>);</span><br><span class="line">  <span class="comment">// switch_to() 在 kernel/process.c 中定义</span></span><br><span class="line">  switch_to(&amp;user_app);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们不应该执行到这里。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>设置satp寄存器为0，表示直接映射模式</li><li>调用load_user_program函数加载用户程序到内存</li><li>调用switch_to函数执行用户程序</li></ul><h3 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h3><p>process结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">process_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// 指向陷入处理时使用的栈。</span></span><br><span class="line">  uint64 kstack;</span><br><span class="line">  <span class="comment">// trapframe 用于存储（用户态）进程的上下文。</span></span><br><span class="line">  trapframe* trapframe;</span><br><span class="line">&#125;process;</span><br></pre></td></tr></table></figure><p>上述进程定义比较简单，主要包括了一个内核栈指针和一个trapframe指针。<br>trapframe用于保存进程的上下文信息，包括寄存器状态、程序计数器等，定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">trapframe_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// 用于存储上下文（所有通用寄存器）的空间</span></span><br><span class="line">  <span class="comment">/* offset:0   */</span> riscv_regs regs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进程的“用户内核”栈</span></span><br><span class="line">  <span class="comment">/* offset:248 */</span> uint64 kernel_sp;</span><br><span class="line">  <span class="comment">// 指向 smode_trap_handler 的指针</span></span><br><span class="line">  <span class="comment">/* offset:256 */</span> uint64 kernel_trap;</span><br><span class="line">  <span class="comment">// 保存的用户程序计数器</span></span><br><span class="line">  <span class="comment">/* offset:264 */</span> uint64 epc;</span><br><span class="line">&#125;trapframe;</span><br></pre></td></tr></table></figure><p>offset表示内部字节的偏移量。<br>主要由以下几个部分组成：</p><ul><li>regs：通用寄存器组</li><li>kernel_sp：内核栈指针</li><li>kernel_trap：内核陷入处理函数指针</li><li>epc：用户程序计数器</li></ul><h3 id="ELF文件加载"><a href="#ELF文件加载" class="headerlink" title="ELF文件加载"></a>ELF文件加载</h3><p>查看加载函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 我们像裸内存映射模式一样，为栈和trap frame使用固定的物理（也是逻辑）地址 */</span></span><br><span class="line"><span class="comment">// 用户栈顶</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_STACK 0x81100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当发生系统调用时，PKE内核使用的栈</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_KSTACK 0x81200000</span></span><br><span class="line"><span class="comment">// 用于组装用户“进程”的trap frame</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_TRAP_FRAME 0x81300000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 加载 ELF 文件，并构造一个仅包含 trapframe 的 &quot;process&quot; 结构体。</span></span><br><span class="line"><span class="comment">// load_bincode_from_host_elf 在 elf.c 中定义。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">load_user_program</span><span class="params">(process *proc)</span> &#123;</span><br><span class="line">  <span class="comment">// USER_TRAP_FRAME 是在 kernel/config.h 中定义的物理地址</span></span><br><span class="line">  proc-&gt;trapframe = (trapframe *)USER_TRAP_FRAME;</span><br><span class="line">  <span class="built_in">memset</span>(proc-&gt;trapframe, <span class="number">0</span>, <span class="keyword">sizeof</span>(trapframe));</span><br><span class="line">  <span class="comment">// USER_KSTACK 也是在 kernel/config.h 中定义的物理地址</span></span><br><span class="line">  proc-&gt;kstack = USER_KSTACK;</span><br><span class="line">  proc-&gt;trapframe-&gt;regs.sp = USER_STACK;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load_bincode_from_host_elf() 在 kernel/elf.c 中定义</span></span><br><span class="line">  load_bincode_from_host_elf(proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是对进程做了初始化，接着调用<code>load_bincode_from_host_elf</code>函数加载用户程序的ELF文件。</p><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1_1"></a>lab1_1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>d074adc89fd:/app/riscv-pke<span class="meta"># spike ./obj/riscv-pke ./obj/app_helloworld </span></span><br><span class="line">In m_start, hartid:<span class="number">0</span></span><br><span class="line">HTIF is available!</span><br><span class="line">(Emulated) memory size: <span class="number">2048</span> MB</span><br><span class="line">Enter supervisor mode...</span><br><span class="line">Application: ./obj/app_helloworld</span><br><span class="line">Application program entry <span class="title function_">point</span> <span class="params">(virtual address)</span>: 0x0000000081000000</span><br><span class="line">Switch to user mode...</span><br><span class="line">call do_syscall to accomplish the syscall and lab1_1 here.</span><br><span class="line"></span><br><span class="line">System is shutting down with <span class="built_in">exit</span> code -1.</span><br></pre></td></tr></table></figure><p>找到<code>do_syscall</code>函数的实现，分析系统调用的处理过程。<br>查看应用程序代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  printu(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是一个简单的用户程序，调用了<code>printu</code>和<code>exit</code>两个系统调用。这两个函数最后都调用了do_user_call函数。继续查看do_user_call函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_user_call</span><span class="params">(uint64 sysnum, uint64 a1, uint64 a2, uint64 a3, uint64 a4, uint64 a5, uint64 a6,</span></span><br><span class="line"><span class="params">                 uint64 a7)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在调用系统调用之前，do_user_call 的参数已经被加载到我们（模拟的）risc-v 机器的参数寄存器（a0-a7）中。</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">      <span class="string">&quot;ecall\n&quot;</span></span></span><br><span class="line"><span class="params">      <span class="string">&quot;sw a0, %0&quot;</span>  <span class="comment">// returns a 32-bit value</span></span></span><br><span class="line"><span class="params">      : <span class="string">&quot;=m&quot;</span>(ret)</span></span><br><span class="line"><span class="params">      :</span></span><br><span class="line"><span class="params">      : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序根据a0寄存器的系统调用号，通过ecall指令触发系统调用，进入S态的trap中。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>围棋</title>
      <link href="/posts/91a2fdce.html"/>
      <url>/posts/91a2fdce.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>B站技术up主</title>
      <link href="/posts/8340f0d1.html"/>
      <url>/posts/8340f0d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="B站技术up主"><a href="#B站技术up主" class="headerlink" title="B站技术up主"></a>B站技术up主</h1><p><a href="https://space.bilibili.com/1969478249">知春路遇上八里桥</a>：操作系统、编译器<br><a href="https://space.bilibili.com/1040264970?spm_id_from=333.1387.follow.user_card.click">正明大佐</a>：操作系统、RISCV架构</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员的自我修养-笔记</title>
      <link href="/posts/ca7583d9.html"/>
      <url>/posts/ca7583d9.html</url>
      
        <content type="html"><![CDATA[<p>本书主要讲述程序在编译、链接和运行时的各种过程。包括：</p><ul><li>代码指令的保存和加载</li><li>库文件如何与应用程序静态链接</li><li>应用程序如何被加载进内存</li><li>动态链接的实现</li><li>C&#x2F;C++库的原理</li><li>OS系统调用的过程</li></ul><h1 id="第-1-部分"><a href="#第-1-部分" class="headerlink" title="第 1 部分"></a>第 1 部分</h1><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：</p><p>先介绍计算机体系结构，以x86指令集为例子。主要由三个部分组成：中央处理器CPU、内存和I&#x2F;O控制芯片。</p><p>为了充分利用CPU，操作系统的发展主要由以下：</p><ol><li>多道程序<br>将多个程序加载到内存中，CPU可以在不同程序间切换执行，提高资源利用率。</li><li>分时系统<br>程序以时间片的方式轮流执行，用户可以同时使用多个程序。</li><li>多任务系统<br>所有程序以进程的方式运行，操作系统负责调度和管理。</li><li>抢占式多任务<br>操作系统可以中断当前进程，切换到其他进程执行，提高响应速度。</li></ol><h1 id="第-2-部分-静态链接"><a href="#第-2-部分-静态链接" class="headerlink" title="第 2 部分 静态链接"></a>第 2 部分 静态链接</h1><p>编译一个程序主要分为4个部分，示意图如下：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/pkelab1_1.excalidraw.7pm0ii5gf.svg"></p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i</span><br></pre></td></tr></table></figure><p>核心：处理以<code>#</code>开头的预处理指令，如<code>#include</code>和<code>#define</code>。<br>处理规则：</p><ol><li>将所有的<code>#define</code>替换为对应的宏定义</li><li>处理所有的条件预编译指令，如<code>#ifdef</code>、<code>#ifndef</code>、<code>#if</code>、<code>#else</code>和<code>#endif</code>。</li><li>处理所有的<code>#include</code>指令，将对应的头文件内容插入到当前位置。</li><li>删除所有注释</li><li>添加行号和文件名</li><li>保留所有的<code>#pragma</code>编译器指令</li></ol><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.i -o main.s</span><br></pre></td></tr></table></figure><p>核心：把预处理完的文件翻译成对应的汇编代码。<br>依赖于编译器的实现。<br>主要由6个组成部分</p><ul><li>扫描</li><li>语法分析</li><li>语义分析</li><li>源代码优化</li><li>代码生成</li><li>目标代码优化</li></ul><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.s -o main.o</span><br></pre></td></tr></table></figure><p>核心：将汇编代码转成机器可执行的指令，输出一个目标文件</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure><p>核心：将所有的目标文件链接成一个可执行文件。</p><h2 id="编译器的作用"><a href="#编译器的作用" class="headerlink" title="编译器的作用"></a>编译器的作用</h2><p>编译的过程，主要由6个组成部分</p><ul><li>扫描(词法分析)<ul><li>使用扫描器将源代码转换成词法单元（tokens）</li></ul></li><li>语法分析<ul><li>使用语法分析器将词法单元转换成语法树（AST）</li><li>语法树：以表达式为节点的树形结构，表示源代码的语法结构</li></ul></li><li>语义分析<ul><li>使用语义分析器检查语法树的语义正确性</li><li>静态语义：在编译时进行的语义检查，如类型检查、作用域检查等</li><li>动态语义：在运行时进行的语义检查，如类型匹配、内存访问等</li></ul></li><li>源代码优化</li><li>代码生成</li><li>目标代码优化</li></ul><h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><p>一个程序的实现包含多个模块，各个模块通过模块间符号进行引用。链接器的作用类似于<br>拼图，将各个模块拼接在一起，形成一个完整的可执行文件。</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>链接的过程就是一个自动组装的过程，其具体包括了地址和空间分配、符号决议和重定位。<br>链接过程如下，各个文件的源码.c经过编译器编译生成目标文件.o，然后目标文件和库文件.a一起链接<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.2obv3p65hr.webp"></p><h1 id="第-3-部分-目标文件"><a href="#第-3-部分-目标文件" class="headerlink" title="第 3 部分 目标文件"></a>第 3 部分 目标文件</h1><h2 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h2><p>目标文件就是编译器编译源代码后生成的文件，通常以.o的形式存在。<br>目标文件的格式与可执行文件的格式采用同一种格式存储，只是此时未进行链接。<br>常见可执行文件分类：</p><ul><li>win：PE格式(.obj)</li><li>Linux&#x2F;Unix：ELF格式(.o)<br>此外，还有一下也按照这种格式存储：</li><li>动态库(DLL)<ul><li>Windows：.dll</li><li>Linux&#x2F;Unix：.so</li></ul></li><li>静态库(Lib)<ul><li>Windows：.lib</li><li>Linux&#x2F;Unix：.a</li></ul></li></ul><h2 id="目标文件内容"><a href="#目标文件内容" class="headerlink" title="目标文件内容"></a>目标文件内容</h2><p>目标文件至少包含编译后的机器指令代码和数据。这些信息按照不同的属性，以section(节)[也称段(segment)]的形式存储。<br>如图可执行文件的格式ELF<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/cxy2.excalidraw.5fkxgpsk5v.svg"></p><p>看的出主要由段表+段内容组成，段表描述文件中各个段的数组。记录了文件各个段的偏移位置和段属性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xv6-riscv</title>
      <link href="/posts/d3f15ab6.html"/>
      <url>/posts/d3f15ab6.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>本文讲解xv6-riscv的物理内存如何管理，页表内核部分的虚拟地址和物理地址的映射关系。<br>对于内存，主要涉及三个问题：</p><ul><li>物理内存管理：怎么分配和回收</li><li>虚拟内存管理：虚拟页怎么分配和回收</li><li>物理内存和虚拟内存的映射关系</li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>不管是物理内存还是虚拟内存，都是以页为单位进行管理的。每页的大小是4KB，即4096字节。<br>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br></pre></td></tr></table></figure><p>对于空闲页的管理，主要有两种常用的方法：</p><ul><li>空闲链表法：将所有的空闲页用链表串起来，分配时就删除一个节点，回收时就插入一个节点</li><li>位图：使用额外的空闲页当作位图，一位表示一页的使用情况，其中1表示被使用，0表示空闲。分配就将对应<br>的位设置为1，回收就将对应的位设置为0。</li></ul><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>xv6-riscv使用的是空闲链表法，先查看定义的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个空闲页</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 自旋锁，用于保护空闲链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span> <span class="comment">// 空闲页链表的头指针</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>示意图：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/pkelab1_2.excalidraw.83acznycd6.svg"><br>其中kmem为物理内存管理器，freelist为空闲页链表的头指针。</p><h4 id="分配回收"><a href="#分配回收" class="headerlink" title="分配回收"></a>分配回收</h4><h5 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：</p><ol><li>对物理内存管理器kmem加锁</li><li>取出空闲页链表的头节点r</li><li>如果r不为空，则将kmem.freelist指向r的下一个节点</li><li>释放锁</li></ol><h5 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：</p><ol><li>检查pa是否是页对齐的地址，且在有效的物理内存范围内</li><li>对物理内存管理器kmem加锁</li><li>使用头插法将r插入到空闲页链表的头部</li></ol><h5 id="回收多个页"><a href="#回收多个页" class="headerlink" title="回收多个页"></a>回收多个页</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kalloc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">freerange</span><span class="params">(<span class="type">void</span> *pa_start, <span class="type">void</span> *pa_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  p = (<span class="type">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="type">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">    kfree(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kinit函数在main调用，对freerange的封装，主要是初始化内存，将内存一页一页的回收，放入空闲链表中。</p><h2 id="页表内核部分"><a href="#页表内核部分" class="headerlink" title="页表内核部分"></a>页表内核部分</h2><h3 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h3><p>本节讲解内核的虚拟地址空间和物理地址空间映射关系如下。<br>首先查看物理地址的分布，主要是参考qemu中hw&#x2F;riscv&#x2F;virt.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理内存布局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt 的物理内存布局如下，参考 qemu 的 hw/riscv/virt.c：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- 启动 ROM，由 qemu 提供</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT（Core Local Interruptor）</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC（平台级中断控制器）</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0（串口）</span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk（虚拟磁盘）</span></span><br><span class="line"><span class="comment">// 80000000 -- qemu 的启动 ROM 会加载内核到这里，然后跳转到这里执行</span></span><br><span class="line"><span class="comment">// 80000000 之后为未使用的 RAM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 内核使用物理内存的方式：</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S，接着是内核的代码和数据段</span></span><br><span class="line"><span class="comment">// end -- 内核页分配区的起始位置</span></span><br><span class="line"><span class="comment">// PHYSTOP -- 内核可用 RAM 的结束位置</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// qemu 将 UART 寄存器映射在物理内存的上述位置。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0 0x10000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART0_IRQ 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// virtio mmio接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0 0x10001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRTIO0_IRQ 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu将平台级中断控制器（PLIC）放在这里。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC 0x0c000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PRIORITY (PLIC + 0x0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_PENDING (PLIC + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核期望在物理地址 0x80000000 到 PHYSTOP 之间有可用的 RAM，用于内核和用户页的分配和使用。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80000000L</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 trampoline 页映射到最高地址，</span></span><br><span class="line"><span class="comment">// 在用户空间和内核空间都可访问。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在trampoline页下方映射内核栈，</span></span><br><span class="line"><span class="comment">// 每个内核栈都被无效的保护页包围。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户内存布局。</span></span><br><span class="line"><span class="comment">// 地址从零开始：</span></span><br><span class="line"><span class="comment">//   代码段（text）</span></span><br><span class="line"><span class="comment">//   原始数据段和bss段</span></span><br><span class="line"><span class="comment">//   固定大小的栈</span></span><br><span class="line"><span class="comment">//   可扩展的堆</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   TRAPFRAME（p-&gt;trapframe，由trampoline使用）</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE（与内核中相同的页）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure><p>整个映射示意图如下：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/xv6-m1.excalidraw.2yyod8a28n.svg"><br>可以看出，内核怒愤的虚拟地址空间和物理地址空间是一一对应的。用户态的部分涉及页表，之后讲解。</p><h3 id="sv39分页机制"><a href="#sv39分页机制" class="headerlink" title="sv39分页机制"></a>sv39分页机制</h3><p>xv6使用sv39分页机制，默认情况下MMU为被使能，通过S特权级的satp寄存器来控制。<br>sv39分页机制的页表结构如下：<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.41ydo5f87j.webp"><br>一个页表项有54位，总共8字节大小，分析页表项结构，如下<br><img src="https://github.com/CJ0510/picx-images-hosting/raw/master/image.96a2dfk9w9.webp"><br>其中[53:10]为44位的物理页号，最低的8位[7:0]为标志位<br>标志位：</p><ul><li>V：有效位，表示该页表项是否有效</li><li>R：可读位，表示该页是否可读</li><li>W：可写位，表示该页是否可写</li><li>X：可执行位，表示该页是否可执行</li><li>U：用户位，表示该页是否可被用户访问</li><li>G：全局位，表示该页是否为全局页</li><li>A：访问位，表示该页是否被访问过</li><li>D：脏位，表示该页是否被修改过</li></ul><h3 id="映射函数"><a href="#映射函数" class="headerlink" title="映射函数"></a>映射函数</h3><p>映射函数就是创建页表项，看下建立内核的页表函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数是对 <code>mappages</code>函数的封装，主要是为了简化内核的页表映射操作。<br>查看 <code>mappages</code>函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;   <span class="comment">// 页表项64位</span></span><br><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs 指向页表的指针</span></span><br><span class="line"><span class="comment">// 将物理地址移到 PTE 的正确位置。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">// 为从 va 开始的虚拟地址创建指向从 pa 开始的物理地址的 PTE。</span></span><br><span class="line"><span class="comment">// va 和 size 必须是页对齐的。</span></span><br><span class="line"><span class="comment">// 成功返回 0，如果 walk() 无法分配所需的页表页则返回 -1。</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: va not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((size % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  a = va;</span><br><span class="line">  last = va + size - PGSIZE;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mappages函数的作用是给定虚拟地址va和大小size，从pa指向的物理地址开始，创建虚拟地址对应的页表项。<br>查看walk函数，实现了sv39分页机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main函数中初始化内核映射的函数是 <code>kvminit</code>，查看其实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the one kernel_pagetable</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>kvminit</code>函数的实现进行分析，主要是调用了 <code>kvmmake</code>函数来创建内核页表。接下来查看 <code>kvmmake</code>函数的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为内核创建一个直接映射的页表。</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart寄存器</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio磁盘接口</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x4000000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射内核代码段（只读且可执行）。</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射内核数据段和将要使用的物理内存。</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将trampoline（陷阱入口/出口）映射到内核中的最高虚拟地址。</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为每个进程分配并映射一个内核栈。</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是调用 <code>kvmmap</code>函数来创建内核的页表项，完成内核虚拟地址和物理地址的映射。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>公共资源</strong>：被多个任务共享的资源，公共内存，也可以是公共文件等等<br><strong>临界区</strong>：访问公共资源的代码区域<br><strong>并发</strong>：多个任务同时执行的情况，单个处理器上<br><strong>并行</strong>：多个任务同时在多个处理器上执行的情况<br><strong>互斥</strong>：任何时候公共资源只能被一个任务访问<br><strong>竞争</strong>：多个任务同时访问公共资源<br><strong>忙等待</strong>：任务没进入临界区一直循环，占用CPU资源<br><strong>休眠等待</strong>：任务进入休眠状态，等待其他任务释放资源，不占用CPU资源</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// 锁是否被持有？</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于调试：</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// 锁的名称。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">cpu</span>;</span>   <span class="comment">// 持有该锁的 CPU。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中最重要的元素是 <code>locked</code>，它表示锁的状态。当 <code>locked</code>为1时，表示锁被持有；当 <code>locked</code>为0时，表示锁可用。自旋锁的基本原理就是通过不断地检查 <code>locked</code>的状态来实现对共享资源的互斥访问。<br>其他元素包括 <code>name</code>和 <code>cpu</code>，前者用于锁的调试，后者表示持有该锁的CPU。</p><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化自旋锁时，将 <code>locked</code>设置为0，表示锁未被持有.</p><h3 id="开关中断"><a href="#开关中断" class="headerlink" title="开关中断"></a>开关中断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">push_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> old = <span class="built_in">intr_get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;noff == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">intr_off</span>();</span><br><span class="line">    <span class="built_in">mycpu</span>()-&gt;intena = old;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pop_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">intr_get</span>())</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push_off</code>函数用于关闭中断。<code>pop_off</code>函数用于恢复之前的中断状态。成对匹配使用。分别对 <code>intr_off</code>和 <code>intr_on</code>函数进行了封装。</p><h3 id="取锁解锁"><a href="#取锁解锁" class="headerlink" title="取锁解锁"></a>取锁解锁</h3><p>获取锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁。</span></span><br><span class="line"><span class="comment">// 循环（自旋）直到获得锁。</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// 禁用中断以避免死锁。</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 RISC-V 上，sync_lock_test_and_set 会被编译为原子交换指令：</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉 C 编译器和处理器不要将加载或存储操作移到此点之前，</span></span><br><span class="line">  <span class="comment">// 以确保临界区的内存访问严格发生在获取锁之后。</span></span><br><span class="line">  <span class="comment">// 在 RISC-V 上，这会发出一个 fence 指令。</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录获取锁的信息，供 holding() 和调试使用。</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会关闭中断防止死锁，然后调用一条原子交换指令amoswap，不断交换<code>locked</code>和<code>1</code>的值，直到成功获取锁。</p><p>释放锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 告诉 C 编译器和 CPU 不要将加载或存储操作移到此点之后，</span></span><br><span class="line">  <span class="comment">// 以确保临界区中的所有存储操作在锁释放之前对其他 CPU 可见，</span></span><br><span class="line">  <span class="comment">// 并且临界区中的加载操作严格发生在锁释放之前。</span></span><br><span class="line">  <span class="comment">// 在 RISC-V 上，这会发出一个 fence 指令。</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁，相当于 lk-&gt;locked = 0。</span></span><br><span class="line">  <span class="comment">// 这里没有使用 C 赋值语句，因为 C 标准暗示赋值可能会被编译为多个存储指令。</span></span><br><span class="line">  <span class="comment">// 在 RISC-V 上，sync_lock_release 会被编译为原子交换指令：</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本质也是调用原子交换指令，将<code>locked</code>设置为0，表示释放锁。</p>]]></content>
      
      
      <categories>
          
          <category> xv6-riscv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
            <tag> riscv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
